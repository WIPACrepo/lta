#!/usr/bin/env python

from typing import Callable
from typing import Dict
import subprocess
import sys
from typing import Union
import webbrowser


def doCleanTask() -> None:
    subprocess.run(["rm", "-fr", ".mypy_cache"])
    subprocess.run(["rm", "-fr", ".pytest_cache"])
    subprocess.run(["rm", "-fr", "build"])
    subprocess.run(["rm", "-fr", "dist"])
    subprocess.run(["rm", "-fr", "htmlcov"])
    subprocess.run(["find", "lta", "-name", "__pycache__", "-exec", "rm", "-fr", "{}", "+"])
    subprocess.run(["rm", "-fr", "lta.egg-info"])
    subprocess.run(["find", "tests", "-name", "__pycache__", "-exec", "rm", "-fr", "{}", "+"])
    subprocess.run(["rm", "-fr", ".coverage"])


def doCoverageTask() -> None:
    doCleanTask()
    subprocess.run(["pytest", "--cov=lta", "--cov-config=.coveragerc", "--cov-report=html", "--no-cov-on-fail", "tests"])
    webbrowser.open_new_tab("htmlcov/index.html")


def doDistTask() -> None:
    doCleanTask()
    doRebuildTask()
    subprocess.run(["python", "setup.py", "sdist", "bdist_wheel"])


def doLintTask() -> None:
    flake8_cmd = ["flake8", "--ignore", "E302,E305,E501,W503,W504"]
    mypy_cmd = ["mypy", "--strict", "--allow-subclassing-any"]
    subprocess.run(flake8_cmd + ["tests"])
    # TODO: Maybe when pytest has a library stub
    # subprocess.run(mypy_cmd + ["tests"])
    subprocess.run(flake8_cmd + ["lta"])
    subprocess.run(mypy_cmd + ["lta"])


def doRebuildTask() -> None:
    doCleanTask()
    subprocess.run(["pytest", "tests"])
    doLintTask()


def doTestTask() -> None:
    doCleanTask()
    subprocess.run(["pytest", "tests"])

# ---------------------------------------------------------------------


def task(name: str,
         description: str,
         action: Callable[[], None]) -> None:
    tasks[name] = {
        "name": name,
        "description": description,
        "action": action
    }


tasks: Dict[str, Dict[str, Union[str, Callable[[], None]]]] = {}

if __name__ == "__main__":
    # define tasks
    task("clean", "Remove build cruft", doCleanTask)
    task("coverage", "Perform coverage analysis", doCoverageTask)
    task("dist", "Create a distribution tarball and wheel", doDistTask)
    task("lint", "Run static analysis tools", doLintTask)
    task("rebuild", "Test and lint the module", doRebuildTask)
    task("test", "Test the module", doTestTask)

    # if the user didn't supply a task
    if len(sys.argv) < 2:
        # provide a menu of tasks to run
        print("Try one of the following tasks:\n")
        taskList = list(tasks.keys())
        taskList.sort()
        for taskName in taskList:
            print(f"snake {taskName:20} # {tasks[taskName]['description']}")
        sys.exit(1)

    # if the user supplied a task that wasn't defined
    if sys.argv[1] not in tasks:
        # tell them and show them how to get the menu
        print(f"No such task: {sys.argv[1]}\n\nTo see a list of all tasks/options, run 'snake'")
        sys.exit(1)

    # run the task the user supplied
    # NOTE: mypy doesn't like the fact that we might accidentally try to call
    #       a string, if such were returned from our Dict
    #       I'm thinking about refactoring tasks to be tuples; but I'm not
    #       going to do that right now, just make a note about it
    tasks[sys.argv[1]]["action"]()
